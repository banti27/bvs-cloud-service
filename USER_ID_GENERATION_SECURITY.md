# User ID Generation Security

## Overview
User IDs are **always generated by the system** and cannot be overridden by client input. This is a critical security measure to prevent ID spoofing and ensure data integrity.

## Implementation

### 1. Entity Level Protection (`User.java`)

```java
@PrePersist
protected void onCreate() {
    // Always generate ID - system override
    // Even if ID is passed, it will be overridden for security
    id = IdGenerator.generate("USR");
    createdAt = LocalDateTime.now();
    updatedAt = LocalDateTime.now();
}
```

**Key Points:**
- ✅ The `@PrePersist` method is called **before** the entity is saved to the database
- ✅ The ID is **always** regenerated, even if someone tries to set it manually
- ✅ No conditional check (`if (id == null)`) - **unconditional override**
- ✅ Uses `IdGenerator.generate("USR")` from `bvs-common-lib`

### 2. DTO Level Protection (`CreateUserRequest.java`)

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {
    private String username;
    private String email;
    private String password;
    private String firstName;
    private String lastName;
    // NO 'id' field - clients cannot provide IDs
}
```

**Key Points:**
- ✅ The `CreateUserRequest` DTO does **not** have an `id` field
- ✅ Clients cannot send an ID in the request body
- ✅ Even if they try to send it, it will be ignored

### 3. Service Level Protection (`UserService.java`)

```java
@Transactional
public UserDTO createUser(CreateUserRequest request) {
    User user = new User();
    // ID is NOT set here - it will be auto-generated by @PrePersist
    user.setUsername(request.getUsername());
    user.setEmail(request.getEmail());
    user.setPassword(passwordEncoder.encode(request.getPassword()));
    user.setFirstName(request.getFirstName());
    user.setLastName(request.getLastName());
    user.setActive(true);

    User savedUser = userRepository.save(user);
    return convertToDTO(savedUser);
}
```

**Key Points:**
- ✅ The service **never** calls `user.setId()`
- ✅ ID generation is delegated to the entity's `@PrePersist` method
- ✅ Single source of truth for ID generation

## ID Format

Generated IDs follow this pattern:
```
USR-20251003143025-A3B9
 │        │         │
 │        │         └─ Random alphanumeric suffix (4 chars)
 │        └─────────── Timestamp (yyyyMMddHHmmss)
 └──────────────────── Prefix (USR for users)
```

**Example IDs:**
- `USR-20251003143025-A3B9`
- `USR-20251003143026-X7M4`
- `USR-20251003143027-K9P2`

## Security Benefits

### 1. Prevents ID Spoofing
```json
// ❌ Client attempts to create user with specific ID
POST /api/users
{
  "id": "USR-00000000000000-HACK",
  "username": "hacker",
  "email": "hacker@example.com"
}

// ✅ System ignores the ID and generates its own
Result: User created with ID "USR-20251003143025-A3B9"
```

### 2. Prevents ID Collision Attacks
- Attacker cannot predict or choose IDs
- Timestamp + random suffix ensures uniqueness
- No sequential IDs (prevents enumeration attacks)

### 3. Prevents Privilege Escalation
- Users cannot create accounts with admin-like IDs
- System maintains control over ID namespace
- Audit trail remains intact

### 4. Prevents Data Integrity Issues
- No duplicate IDs possible
- Consistent ID format across all users
- Database constraints are never violated

## Testing ID Generation Security

### Test 1: Attempt to Pass ID in Request
```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "id": "USR-MALICIOUS-HACK",
    "username": "testuser",
    "email": "test@example.com",
    "password": "password123"
  }'
```

**Expected Result:**
- Request succeeds (ID field is ignored)
- User is created with system-generated ID
- Response shows different ID than what was sent

### Test 2: Direct Entity Creation (Internal Test)
```java
@Test
void testIdGenerationOverride() {
    User user = new User();
    user.setId("CUSTOM-ID");  // Attempt to set custom ID
    user.setUsername("testuser");
    user.setEmail("test@example.com");
    user.setPassword("password");
    
    User saved = userRepository.save(user);
    
    // ID should be system-generated, not "CUSTOM-ID"
    assertThat(saved.getId()).startsWith("USR-");
    assertThat(saved.getId()).isNotEqualTo("CUSTOM-ID");
}
```

### Test 3: Verify ID Format
```java
@Test
void testIdFormat() {
    User user = createTestUser();
    User saved = userRepository.save(user);
    
    // Verify ID matches pattern: USR-TIMESTAMP-SUFFIX
    assertThat(saved.getId()).matches("^USR-\\d{14}-[A-Z0-9]{4}$");
}
```

## How It Works (Flow Diagram)

```
Client Request
     │
     ├─> CreateUserRequest (no ID field)
     │
     ├─> UserService.createUser()
     │       │
     │       ├─> new User() (ID is null)
     │       ├─> set other fields (username, email, etc.)
     │       └─> userRepository.save()
     │
     ├─> @PrePersist Hook Triggered
     │       │
     │       ├─> Override ANY existing ID value
     │       └─> id = IdGenerator.generate("USR")
     │
     ├─> Database Insert (with system-generated ID)
     │
     └─> Response (UserDTO with new ID)
```

## Best Practices

### ✅ DO:
- Let the system generate all user IDs
- Use `@PrePersist` for ID generation
- Remove ID field from create/update DTOs
- Document the ID generation logic
- Test ID generation security

### ❌ DON'T:
- Allow clients to specify IDs
- Use conditional ID generation (`if (id == null)`)
- Expose ID generation logic to clients
- Use sequential/predictable IDs
- Trust client-provided IDs

## Additional Security Measures

### 1. Controller Level Validation
You can add explicit validation in the controller:

```java
@PostMapping
public ResponseEntity<ApiResponse<UserDTO>> createUser(@RequestBody CreateUserRequest request) {
    // Note: ID is never accepted in the request
    UserDTO user = userService.createUser(request);
    return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success("User created successfully", user));
}
```

### 2. Update Operations
For user updates, ensure the ID cannot be changed:

```java
@PutMapping("/{id}")
public ResponseEntity<ApiResponse<UserDTO>> updateUser(
        @PathVariable String id,
        @RequestBody UpdateUserRequest request) {
    // ID comes from path parameter, not request body
    UserDTO user = userService.updateUser(id, request);
    return ResponseEntity.ok(ApiResponse.success("User updated", user));
}
```

### 3. Audit Logging
Log all user creation events with the generated ID:

```java
@Transactional
public UserDTO createUser(CreateUserRequest request) {
    User savedUser = userRepository.save(user);
    log.info("User created with system-generated ID: {}", savedUser.getId());
    return convertToDTO(savedUser);
}
```

## Configuration

The ID generation is configured in `bvs-common-lib`:

```java
// IdGenerator.java
public static String generate(String prefix) {
    return generate(prefix, 4); // 4-character suffix
}

public static String generate(String prefix, int suffixLength) {
    String timestamp = LocalDateTime.now()
        .format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
    String suffix = generateRandomSuffix(suffixLength);
    return prefix + "-" + timestamp + "-" + suffix;
}
```

## Compliance

This implementation helps with:
- **GDPR**: Prevents user ID enumeration
- **SOC 2**: Ensures data integrity controls
- **PCI DSS**: Prevents ID-based attacks
- **OWASP**: Mitigates insecure direct object references (IDOR)

## Summary

| Security Measure | Status | Implementation |
|-----------------|--------|----------------|
| ID auto-generation | ✅ | `@PrePersist` with unconditional override |
| DTO without ID field | ✅ | `CreateUserRequest` has no `id` |
| Service-level protection | ✅ | Never calls `setId()` |
| Unpredictable IDs | ✅ | Timestamp + random suffix |
| Format validation | ✅ | `IdGenerator.isValid()` |
| Audit logging | ⚠️ | Recommended to add |
| Unit tests | ⚠️ | Recommended to add |

**Current Status**: ✅ Secure - User IDs cannot be overridden by clients

---

**Last Updated**: October 3, 2025
**Module**: bvs-user-service
**Related Files**: 
- `User.java` (Entity with @PrePersist)
- `UserService.java` (Service layer)
- `CreateUserRequest.java` (DTO)
- `IdGenerator.java` (Common library)
